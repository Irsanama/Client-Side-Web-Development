<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Паззл</title>
    <style>
        body {
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .puzzle-area {
            width: 450px;
            height: 300px;
            border: 2px solid #333;
            position: relative;
            background-color: white;
            overflow: hidden;
        }

        .puzzle-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0;
            pointer-events: none;
            z-index: 1;
        }

        .puzzle-cell {
            border: 1px solid #aaa;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .puzzle-background {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0.3;
            z-index: 0;
            pointer-events: none;
        }

        .puzzle-tiles {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .tiles-container {
            width: 450px;
            height: 300px;
            border: 2px solid #333;
            background-color: white;
            position: relative;
            overflow: hidden;
        }

        .tile {
            width: 50px;
            height: 50px;
            position: absolute;
            cursor: grab;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
            transition: all 0.3s ease;
            z-index: 10;
            touch-action: none;
        }

        .tile.dragging {
            opacity: 0.9;
            cursor: grabbing;
            z-index: 1000;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile.correct {
            border-color: transparent;
        }

        .puzzle-area.completed .puzzle-cell {
            border-color: transparent;
            background-color: transparent;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0b7dda;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            display: none;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            animation: fadeIn 1s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            opacity: 0;
            z-index: 1001;
            pointer-events: none;
        }
    </style>
</head>
<body>
<h1>Паззл</h1>

<div class="controls">
    <input type="file" id="imageUpload" accept="image/*">
    <button id="shuffleBtn" disabled>Перемешать</button>
</div>

<div class="game-container">
    <div class="tiles-container" id="tilesContainer"></div>
    <div class="puzzle-area" id="puzzleArea">
        <div class="puzzle-grid" id="puzzleGrid"></div>
        <div class="puzzle-background" id="puzzleBackground"></div>
        <div class="puzzle-tiles" id="puzzleTiles"></div>
    </div>
</div>

<div class="message" id="message"></div>

<script>
    class PuzzleGame {
        constructor() {
            // Конфигурация игры
            this.PUZZLE_WIDTH = 450;
            this.PUZZLE_HEIGHT = 300;
            this.TILE_SIZE = 50;
            this.COLS = 9;
            this.ROWS = 6;

            // Состояние игры
            this.tiles = [];
            this.draggedTile = null;
            this.originalImage = null;
            this.isDragging = false;
            this.originalContainer = null;
            this.originalRow = 0;
            this.originalCol = 0;

            // DOM элементы.
            this.elements = {
                imageUpload: document.getElementById('imageUpload'),
                shuffleBtn: document.getElementById('shuffleBtn'),
                tilesContainer: document.getElementById('tilesContainer'),
                puzzleArea: document.getElementById('puzzleArea'),
                puzzleBackground: document.getElementById('puzzleBackground'),
                puzzleTiles: document.getElementById('puzzleTiles'),
                puzzleGrid: document.getElementById('puzzleGrid'),
                message: document.getElementById('message')
            };
            this.init();
        }

        init() {
            this.bindEvents();
        }

        bindEvents() {
            this.elements.imageUpload.addEventListener('change', (e) => this.handleImageUpload(e));
            this.elements.shuffleBtn.addEventListener('click', () => this.shuffleTiles());

            // Глобальные обработчики перетаскивания
            document.addEventListener('mousemove', (e) => this.doDrag(e));
            document.addEventListener('mouseup', (e) => this.stopDrag(e));
            document.addEventListener('touchmove', (e) => this.doDrag(e), { passive: false });
            document.addEventListener('touchend', (e) => this.stopDrag(e));
        }

        handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                this.originalImage = new Image();
                this.originalImage.onload = () => {
                    this.createPuzzle();
                    this.elements.shuffleBtn.disabled = false;
                };
                this.originalImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        createPuzzle() {
            this.clearContainers();
            this.createGrid();
            this.setPuzzleBackground();
            this.createTiles();
            this.shuffleTiles();
        }

        clearContainers() {
            this.elements.tilesContainer.innerHTML = '';
            this.elements.puzzleTiles.innerHTML = '';
            this.elements.puzzleGrid.innerHTML = '';
            this.tiles = [];
        }

        createGrid() {
            for (let row = 0; row < this.ROWS; row++) {
                for (let col = 0; col < this.COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'puzzle-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    this.elements.puzzleGrid.appendChild(cell);
                }
            }
        }

        setPuzzleBackground() {
            this.elements.puzzleBackground.style.backgroundImage = `url(${this.originalImage.src})`;
            this.elements.puzzleBackground.style.backgroundSize = `${this.PUZZLE_WIDTH}px ${this.PUZZLE_HEIGHT}px`;
        }

        createTiles() {
            for (let row = 0; row < this.ROWS; row++) {
                for (let col = 0; col < this.COLS; col++) {
                    const tile = this.createTile(row, col);
                    this.elements.tilesContainer.appendChild(tile.element);
                    this.tiles.push(tile);
                }
            }
        }

        createTile(row, col) {
            const tileElement = document.createElement('div');
            tileElement.className = 'tile';

            const bgX = -col * this.TILE_SIZE;
            const bgY = -row * this.TILE_SIZE;

            tileElement.style.backgroundImage = `url(${this.originalImage.src})`;
            tileElement.style.backgroundPosition = `${bgX}px ${bgY}px`;
            tileElement.style.backgroundSize = `${this.PUZZLE_WIDTH}px ${this.PUZZLE_HEIGHT}px`;

            const tile = {
                element: tileElement,
                correctRow: row,
                correctCol: col,
                currentContainer: 'tiles',
                currentRow: row,
                currentCol: col
            };

            // Обработчики перетаскивания
            tileElement.addEventListener('mousedown', (e) => this.startDrag(e, tile));
            tileElement.addEventListener('touchstart', (e) => this.startDrag(e, tile), { passive: false });

            return tile;
        }

        startDrag(e, tile) {
            e.preventDefault();
            this.draggedTile = tile;
            this.isDragging = true;

            this.originalContainer = tile.element.parentElement;
            this.originalRow = tile.currentRow;
            this.originalCol = tile.currentCol;

            const { clientX, clientY } = this.getClientCoordinates(e);
            const rect = tile.element.getBoundingClientRect();

            this.dragOffsetX = clientX - rect.left;
            this.dragOffsetY = clientY - rect.top;

            document.body.appendChild(tile.element);
            tile.element.style.position = 'fixed';
            tile.element.style.zIndex = '1000';
            tile.element.style.left = `${rect.left}px`;
            tile.element.style.top = `${rect.top}px`;

            tile.element.classList.add('dragging');
        }

        doDrag(e) {
            if (!this.draggedTile || !this.isDragging) return;

            const { clientX, clientY } = this.getClientCoordinates(e);
            if (clientX === undefined || clientY === undefined) return;

            this.draggedTile.element.style.left = `${clientX - this.dragOffsetX}px`;
            this.draggedTile.element.style.top = `${clientY - this.dragOffsetY}px`;
        }

        stopDrag(e) {
            if (!this.draggedTile || !this.isDragging) return;

            this.draggedTile.element.classList.remove('dragging');
            const { clientX, clientY } = this.getClientCoordinates(e, true);

            const tilesRect = this.elements.tilesContainer.getBoundingClientRect();
            const puzzleRect = this.elements.puzzleArea.getBoundingClientRect();

            if (this.isOverPuzzleArea(clientX, clientY, puzzleRect)) {
                this.handlePuzzleAreaDrop(clientX, clientY, puzzleRect);
            } else if (this.isOverTilesArea(clientX, clientY, tilesRect)) {
                this.handleTilesAreaDrop(clientX, clientY, tilesRect);
            } else {
                this.returnToOriginalContainer();
            }
            this.resetDragState();
        }

        getClientCoordinates(e, isEndEvent = false) {
            if (e.type.includes('touch')) {
                const touch = isEndEvent ? e.changedTouches[0] : e.touches[0];
                return { clientX: touch.clientX, clientY: touch.clientY };
            }
            return { clientX: e.clientX, clientY: e.clientY };
        }

        isOverPuzzleArea(x, y, rect) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }

        isOverTilesArea(x, y, rect) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }

        handlePuzzleAreaDrop(clientX, clientY, puzzleRect) {
            const x = clientX - puzzleRect.left;
            const y = clientY - puzzleRect.top;
            const targetCol = Math.floor(x / this.TILE_SIZE);
            const targetRow = Math.floor(y / this.TILE_SIZE);

            if (this.isValidPosition(targetRow, targetCol)) {
                const occupiedTile = this.findTileAtPosition(targetRow, targetCol);

                if (!occupiedTile) {
                    this.placeTileInPuzzle(this.draggedTile, targetRow, targetCol);
                } else {
                    if (this.originalContainer === this.elements.tilesContainer) {
                        this.replaceTileInPuzzle(this.draggedTile, occupiedTile, targetRow, targetCol);
                    } else {
                        this.swapTiles(this.draggedTile, occupiedTile);
                    }
                }
            } else {
                this.returnToOriginalContainer();
            }
        }

        handleTilesAreaDrop(clientX, clientY, tilesRect) {
            this.elements.tilesContainer.appendChild(this.draggedTile.element);
            this.draggedTile.element.style.position = 'absolute';
            this.draggedTile.element.style.zIndex = '10';

            if (this.draggedTile.currentContainer === 'puzzle') {
                this.draggedTile.currentContainer = 'tiles';
                this.draggedTile.element.classList.remove('correct');
            }

            const x = clientX - tilesRect.left - this.TILE_SIZE/2;
            const y = clientY - tilesRect.top - this.TILE_SIZE/2;

            const boundedX = Math.max(0, Math.min(x, tilesRect.width - this.TILE_SIZE));
            const boundedY = Math.max(0, Math.min(y, tilesRect.height - this.TILE_SIZE));

            this.draggedTile.element.style.left = `${boundedX}px`;
            this.draggedTile.element.style.top = `${boundedY}px`;

            this.draggedTile.currentRow = Math.floor(boundedY / this.TILE_SIZE);
            this.draggedTile.currentCol = Math.floor(boundedX / this.TILE_SIZE);
        }

        isValidPosition(row, col) {
            return col >= 0 && col < this.COLS && row >= 0 && row < this.ROWS;
        }

        findTileAtPosition(row, col) {
            return this.tiles.find(t =>
                t !== this.draggedTile &&
                t.currentContainer === 'puzzle' &&
                t.currentRow === row &&
                t.currentCol === col
            );
        }

        placeTileInPuzzle(tile, row, col) {
            this.elements.puzzleTiles.appendChild(tile.element);
            tile.element.style.position = 'absolute';
            tile.element.style.zIndex = '10';

            tile.currentRow = row;
            tile.currentCol = col;
            tile.currentContainer = 'puzzle';

            tile.element.style.left = `${col * this.TILE_SIZE}px`;
            tile.element.style.top = `${row * this.TILE_SIZE}px`;

            this.updateTileCorrectness(tile);
            this.checkPuzzleComplete();
        }

        replaceTileInPuzzle(newTile, oldTile, row, col) {
            this.elements.tilesContainer.appendChild(oldTile.element);
            oldTile.element.style.position = 'absolute';
            oldTile.element.style.zIndex = '10';
            oldTile.currentContainer = 'tiles';
            oldTile.element.classList.remove('correct');

            const maxX = this.elements.tilesContainer.offsetWidth - this.TILE_SIZE;
            const maxY = this.elements.tilesContainer.offsetHeight - this.TILE_SIZE;
            const randomX = Math.floor(Math.random() * maxX);
            const randomY = Math.floor(Math.random() * maxY);

            oldTile.element.style.left = `${randomX}px`;
            oldTile.element.style.top = `${randomY}px`;
            oldTile.currentRow = Math.floor(randomY / this.TILE_SIZE);
            oldTile.currentCol = Math.floor(randomX / this.TILE_SIZE);

            this.placeTileInPuzzle(newTile, row, col);
        }

        swapTiles(tile1, tile2) {
            const tile1Row = tile1.currentRow;
            const tile1Col = tile1.currentCol;
            const tile2Row = tile2.currentRow;
            const tile2Col = tile2.currentCol;

            [tile1.currentRow, tile2.currentRow] = [tile2Row, tile1Row];
            [tile1.currentCol, tile2.currentCol] = [tile2Col, tile1Col];

            this.elements.puzzleTiles.appendChild(tile1.element);
            this.elements.puzzleTiles.appendChild(tile2.element);

            tile1.element.style.position = 'absolute';
            tile2.element.style.position = 'absolute';

            tile1.element.style.left = `${tile2Col * this.TILE_SIZE}px`;
            tile1.element.style.top = `${tile2Row * this.TILE_SIZE}px`;
            tile2.element.style.left = `${tile1Col * this.TILE_SIZE}px`;
            tile2.element.style.top = `${tile1Row * this.TILE_SIZE}px`;

            this.updateTileCorrectness(tile1);
            this.updateTileCorrectness(tile2);

            this.checkPuzzleComplete();
        }

        updateTileCorrectness(tile) {
            const isCorrect = tile.currentRow === tile.correctRow && tile.currentCol === tile.correctCol;
            tile.element.classList.toggle('correct', isCorrect);
        }

        returnToOriginalContainer() {
            if (!this.draggedTile) return;

            if (this.originalContainer === this.elements.tilesContainer) {
                this.returnToTilesContainer();
            } else {
                this.returnToPuzzlePosition();
            }
        }

        returnToTilesContainer() {
            this.elements.tilesContainer.appendChild(this.draggedTile.element);
            this.draggedTile.element.style.position = 'absolute';
            this.draggedTile.element.style.zIndex = '10';

            const maxX = this.elements.tilesContainer.offsetWidth - this.TILE_SIZE;
            const maxY = this.elements.tilesContainer.offsetHeight - this.TILE_SIZE;
            const randomX = Math.floor(Math.random() * maxX);
            const randomY = Math.floor(Math.random() * maxY);

            this.draggedTile.element.style.left = `${randomX}px`;
            this.draggedTile.element.style.top = `${randomY}px`;

            this.draggedTile.currentContainer = 'tiles';
            this.draggedTile.currentRow = Math.floor(randomY / this.TILE_SIZE);
            this.draggedTile.currentCol = Math.floor(randomX / this.TILE_SIZE);
            this.draggedTile.element.classList.remove('correct');
        }

        returnToPuzzlePosition() {
            this.elements.puzzleTiles.appendChild(this.draggedTile.element);
            this.draggedTile.element.style.position = 'absolute';
            this.draggedTile.element.style.zIndex = '10';
            this.draggedTile.element.style.left = `${this.originalCol * this.TILE_SIZE}px`;
            this.draggedTile.element.style.top = `${this.originalRow * this.TILE_SIZE}px`;
            this.draggedTile.currentRow = this.originalRow;
            this.draggedTile.currentCol = this.originalCol;
            this.updateTileCorrectness(this.draggedTile);
        }

        resetDragState() {
            this.draggedTile = null;
            this.isDragging = false;
            this.originalContainer = null;
        }

        shuffleTiles() {
            this.hideMessage();
            this.elements.puzzleArea.classList.remove('completed');

            this.tiles.forEach(tile => {
                if (tile.currentContainer === 'puzzle') {
                    this.elements.tilesContainer.appendChild(tile.element);
                    tile.currentContainer = 'tiles';
                    tile.element.classList.remove('correct');
                }

                const maxX = this.elements.tilesContainer.offsetWidth - this.TILE_SIZE;
                const maxY = this.elements.tilesContainer.offsetHeight - this.TILE_SIZE;
                const randomX = Math.floor(Math.random() * maxX);
                const randomY = Math.floor(Math.random() * maxY);

                tile.element.style.left = `${randomX}px`;
                tile.element.style.top = `${randomY}px`;

                tile.currentRow = Math.floor(randomY / this.TILE_SIZE);
                tile.currentCol = Math.floor(randomX / this.TILE_SIZE);
            });
        }

        checkPuzzleComplete() {
            const isComplete = this.tiles.every(tile =>
                tile.currentContainer === 'puzzle' &&
                tile.currentRow === tile.correctRow &&
                tile.currentCol === tile.correctCol
            );

            if (isComplete) {
                this.showSuccessMessage();
                this.elements.puzzleArea.classList.add('completed');
                this.startCompletionEffect();
            }
        }

        hideMessage() {
            this.elements.message.style.display = 'none';
        }

        showSuccessMessage() {
            this.elements.message.textContent = 'Поздравляем! Паззл собран!';
            this.elements.message.className = 'message success';
            this.elements.message.style.display = 'block';
        }

        startCompletionEffect() {
            this.tiles.forEach(tile => {
                if (tile.currentContainer === 'puzzle') {
                    tile.element.style.animation = 'pulse 1.5s ease-in-out';
                }
            });

            this.createConfetti();
        }

        createConfetti() {
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            const confettiCount = 50;

            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.top = `${Math.random() * 100}vh`;
                document.body.appendChild(confetti);

                confetti.animate([
                    { opacity: 0, transform: 'translateY(-100px) rotate(0deg)' },
                    { opacity: 1, transform: 'translateY(0) rotate(180deg)' },
                    { opacity: 0, transform: 'translateY(100px) rotate(360deg)' }
                ], {
                    duration: 2000 + Math.random() * 1000,
                    easing: 'cubic-bezier(0.1, 0.8, 0.2, 1)',
                    fill: 'forwards'
                });

                setTimeout(() => confetti.remove(), 3000);
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => new PuzzleGame());
</script>
</body>
</html>